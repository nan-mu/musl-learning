#!/bin/sh

usage() {
    cat <<EOF
用法: $0 [选项]... [变量=值]... [目标]

若希望指定诸如 CC、CFLAGS、CROSS_COMPILE 等环境变量的值，
可以使用如下形式：变量名=值。详情请参见下文。

方括号中的内容为默认值。

译者按：
  - [detected]表示默认情况由程序自动生成合理的值
  - [auto] 表示自动选择musl推荐的值
  - TARGET 表示架构类型，musl支持：（大部分支持项是有条件的）
      - x86 / IA32 (i386)
      - x86_64 / AMD64 (x86_64, x32)
      - ARM (arm[eb][hf])
      - AArch64 (aarch64[_be])
      - MIPS (mips[r6][el][-sf], mips64[r6][el][-sf], mipsn32[r6][el][-sf])
      - PowerPC (powerpc[-sf], powerpc64[le])
      - RISC-V (riscv64[-sp|-sf])
      - Microblaze (microblaze[el])
      - OpenRISC 1000 (or1k)
      - SuperH (sh[eb][-nofpu][-fdpic])*
      - IBM S/390 (s390x)：仅支持 64 位
      - Motorola 680x0 (m68k)：仅支持硬浮动
  - PREFIX 与其记作前缀，不如记作根目录
  - wrapper 译作包装器，比如直接使用的gcc就是一种包装器，它包装了预处理，汇编，编译，加密等步骤

配置项：
  --srcdir=DIR            musl 源代码目录 [当前目录]

安装文件存放目录：
  --prefix=PREFIX         首要的安装目录前缀 [/usr/local/musl]
  --exec-prefix=EPREFIX   可执行文件的安装目录前缀 [PREFIX]

安装目录子目录配置：
  --bindir=DIR            用户的可执行文件 [EPREFIX/bin]
  --libdir=DIR            供链接器使用的静态库目录 [PREFIX/lib] # REVIEW: 需要核实是否真全是静态库
  --includedir=DIR        供C编译器使用的头文件目录 [PREFIX/include]
  --syslibdir=DIR         动态库的位置 [/lib] （文档表示应该在不可能于/lib安装的时候才应该覆盖这个值）

系统类型：
  --target=TARGET         配置运行主机的 TARGET [detected]
  --host=HOST             与 --target 作用相同
  --build=BUILD           用于构建的架构类型；一般只在交叉编译时使用

可选功能项:
  --enable-optimize=...   使用给定的组建以优化编译速度（并非大小） [auto] # REVIEW: 速度是使用musl的速度还是编译速度？大小也一样
  --enable-debug          启用则将以debug模式进行构建 [disabled] （也可以手动添加-g在CFLAGS。未来还可能添加更多调试功能）
  --disable-warnings      启用后构建时将输出musl推荐的警告 [enabled]
  --enable-wrapper=...    使用给定的编译器包装器 [auto] 
  --disable-shared        在不需要libc.so时取消构建动态库libc.so；这将缩短一半的构建时间 [enabled]
  --disable-static        在不需要libc.a 时取消构建静态库libc.a ；这将缩短一半的构建时间 [enabled]

可选内容:
  --with-malloc=...       使用给定的malloc [mallocng]

一些关键环境变量:
  CC                      用于替换默认的C编译器 [detected]
  CFLAGS                  用于传递自定义选项给C编译器 [-Os -pipe ...]
  CROSS_COMPILE           交叉编译器或工具链的前缀 [none]
  LIBCC                   添加编译运行时库（译者按：在提交记录中有说在这里可以配置为llvm的工具链） [detected]

使用这些变量来覆盖 configure（本脚本）所做的选择。

EOF
    exit 0
}

# 辅助函数

quote() {
    tr '\n' ' ' <<EOF | grep '^[-[:alnum:]_=,./:]* $' >/dev/null 2>&1 && {
$1
EOF
        echo "$1"
        return 0
    }
    printf %s\\n "$1" | sed -e "s/'/'\\\\''/g" -e "1s/^/'/" -e "\$s/\$/'/" -e "s#^'\([-[:alnum:]_,./:]*\)=\(.*\)\$#\1='\2#"
}
echo() { printf "%s\n" "$*"; }
fail() {
    echo "$*"
    exit 1
}
fnmatch() { eval "case \"\$2\" in $1) return 0 ;; *) return 1 ;; esac"; }
cmdexists() { type "$1" >/dev/null 2>&1; }
trycc() { test -z "$CC" && cmdexists "$1" && CC=$1; }

stripdir() {
    while eval "fnmatch '*/' \"\${$1}\""; do eval "$1=\${$1%/}"; done
}

trycppif() {
    printf "检查 %s 是否被预处理器接受... " "$1"
    echo "typedef int x;" >"$tmpc"
    echo "#if $1" >>"$tmpc"
    echo "#error yes" >>"$tmpc"
    echo "#endif" >>"$tmpc"
    if $CC $2 -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
        printf "否\n"
        return 1
    else
        printf "是\n"
        return 0
    fi
}

tryflag() {
    printf "检查标志 %s 是否被编译器接受... " "$2"
    echo "typedef int x;" >"$tmpc"
    if $CC $CFLAGS_TRY $2 -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
        printf "成功\n"
        eval "$1=\"\${$1} \$2\""
        eval "$1=\${$1# }"
        return 0
    else
        printf "失败\n"
        return 1
    fi
}

tryldflag() {
    printf "检查标志 %s 是否被链接器接受... " "$2"
    echo "typedef int x;" >"$tmpc"
    if $CC $LDFLAGS_TRY -nostdlib -shared "$2" -o /dev/null "$tmpc" >/dev/null 2>&1; then
        printf "成功\n"
        eval "$1=\"\${$1} \$2\""
        eval "$1=\${$1# }"
        return 0
    else
        printf "失败\n"
        return 1
    fi
}

# 实际脚本的开头

CFLAGS_C99FSE=
CFLAGS_AUTO=
CFLAGS_MEMOPS=
CFLAGS_NOSSP=
CFLAGS_TRY=
LDFLAGS_AUTO=
LDFLAGS_TRY=
OPTIMIZE_GLOBS=
srcdir=
prefix=/usr/local/musl
exec_prefix='$(prefix)'
bindir='$(exec_prefix)/bin'
libdir='$(prefix)/lib'
includedir='$(prefix)/include'
syslibdir='/lib'
tools=
tool_libs=
build=
target=
optimize=auto
debug=no
warnings=yes
shared=auto
static=yes
wrapper=auto
gcc_wrapper=no
clang_wrapper=no
malloc_dir=mallocng

for arg; do
    case "$arg" in
    --help | -h) usage ;;
    --srcdir=*) srcdir=${arg#*=} ;;
    --prefix=*) prefix=${arg#*=} ;;
    --exec-prefix=*) exec_prefix=${arg#*=} ;;
    --bindir=*) bindir=${arg#*=} ;;
    --libdir=*) libdir=${arg#*=} ;;
    --includedir=*) includedir=${arg#*=} ;;
    --syslibdir=*) syslibdir=${arg#*=} ;;
    --enable-shared | --enable-shared=yes) shared=yes ;;
    --disable-shared | --enable-shared=no) shared=no ;;
    --enable-static | --enable-static=yes) static=yes ;;
    --disable-static | --enable-static=no) static=no ;;
    --enable-optimize) optimize=yes ;;
    --enable-optimize=*) optimize=${arg#*=} ;;
    --disable-optimize) optimize=no ;;
    --enable-debug | --enable-debug=yes) debug=yes ;;
    --disable-debug | --enable-debug=no) debug=no ;;
    --enable-warnings | --enable-warnings=yes) warnings=yes ;;
    --disable-warnings | --enable-warnings=no) warnings=no ;;
    --enable-wrapper | --enable-wrapper=yes) wrapper=detect ;;
    --enable-wrapper=all)
        wrapper=yes
        gcc_wrapper=yes
        clang_wrapper=yes
        ;;
    --enable-wrapper=gcc)
        wrapper=yes
        gcc_wrapper=yes
        ;;
    --enable-wrapper=clang)
        wrapper=yes
        clang_wrapper=yes
        ;;
    --disable-wrapper | --enable-wrapper=no) wrapper=no ;;
    --enable-gcc-wrapper | --enable-gcc-wrapper=yes)
        wrapper=yes
        gcc_wrapper=yes
        ;;
    --disable-gcc-wrapper | --enable-gcc-wrapper=no) wrapper=no ;;
    --with-malloc=*) malloc_dir=${arg#*=} ;;
    --enable-* | --disable-* | --with-* | --without-* | --*dir=*) ;;
    --host=* | --target=*) target=${arg#*=} ;;
    --build=*) build=${arg#*=} ;;
    -*) echo "$0: unknown option $arg" ;;
    AR=*) AR=${arg#*=} ;;
    RANLIB=*) RANLIB=${arg#*=} ;;
    CC=*) CC=${arg#*=} ;;
    CFLAGS=*) CFLAGS=${arg#*=} ;;
    CPPFLAGS=*) CPPFLAGS=${arg#*=} ;;
    LDFLAGS=*) LDFLAGS=${arg#*=} ;;
    CROSS_COMPILE=*) CROSS_COMPILE=${arg#*=} ;;
    LIBCC=*) LIBCC=${arg#*=} ;;
    *=*) ;;
    *)
        build=$arg
        target=$arg
        ;;
    esac
done

for i in srcdir prefix exec_prefix bindir libdir includedir syslibdir; do
    stripdir $i
done

#
# 为了避免编译过程污染源代码目录，进行检查并输出一个干净的目录
#
if test -z "$srcdir"; then
    srcdir="${0%/configure}"
    stripdir srcdir
fi
abs_builddir="$(pwd)" || fail "$0: 无法确定工作目录"
abs_srcdir="$(cd $srcdir && pwd)" || fail "$0: 无效的源代码目录 $srcdir"
test "$abs_srcdir" = "$abs_builddir" && srcdir=.
test "$srcdir" != "." && test -f Makefile && test ! -h Makefile && fail "$0: 工作目录中已经存在 Makefile 文件"

#
# 得到一个可用的临时文件名
#
i=0
set -C
while :; do
    i=$(($i + 1))
    tmpc="./conf$$-$PPID-$i.c"
    2>|/dev/null >"$tmpc" && break
    test "$i" -gt 50 && fail "$0: 无法创建临时文件 $tmpc"
done
set +C
trap 'rm "$tmpc"' EXIT INT QUIT TERM HUP

#
# 检查要求的malloc实现是否存在
#
test -d "$srcdir/src/malloc/$malloc_dir" ||
    fail "$0: 错误：选择的malloc实现 '$malloc_dir' 并不存在"

#
# 检查是否正在进行交叉编译
# 并在 CROSS_COMPILE 为空的时候设定一个默认值
#
test "$target" &&
    test "$target" != "$build" &&
    test -z "$CROSS_COMPILE" &&
    CROSS_COMPILE="$target-"

#
# 找到一个可用的C编译器
#
printf "检查C编译器... "
trycc ${CROSS_COMPILE}gcc
trycc ${CROSS_COMPILE}c99
trycc ${CROSS_COMPILE}cc
printf "%s\n" "$CC"
test -n "$CC" || {
    echo "$0: 无法找到一个正确的C编译器"
    exit 1
}

printf "检查编译器是否正常... "
echo "typedef int x;" >"$tmpc"
if output=$($CC $CPPFLAGS $CFLAGS -c -o /dev/null "$tmpc" 2>&1); then
    printf "成功\n"
else
    printf "失败；编译器输出为：\n%s\n" "$output"
    exit 1
fi

#
# 找出可用于强制启用未知标志的标志可选项
# 提交记录中表示如clang这类编译器在接受未知标志时不会报错，但之后这个错误可能会在之后输出。
# 这会破坏处理输出的程序，所以我们需要一个标志来强制启用未知标志报错。
#
tryflag CFLAGS_TRY -Werror=unknown-warning-option
tryflag CFLAGS_TRY -Werror=unused-command-line-argument
tryflag CFLAGS_TRY -Werror=ignored-optimization-argument
tryldflag LDFLAGS_TRY -Werror=unknown-warning-option
tryldflag LDFLAGS_TRY -Werror=unused-command-line-argument

#
# 使用的编译器是gcc还是clang来选择使用的包装器
#
printf "checking for C compiler family... "
cc_ver="$(LC_ALL=C $CC -v 2>&1)"
cc_family=unknown
if fnmatch '*gcc\ version*' "$cc_ver"; then
    cc_family=gcc
elif fnmatch '*clang\ version*' "$cc_ver"; then
    cc_family=clang
fi
echo "$cc_family"

#
# 找到用于构建的工具链包装器
#
if test "$wrapper" = auto || test "$wrapper" = detect; then
    echo "#include <stdlib.h>" >"$tmpc"
    echo "#if ! __GLIBC__" >>"$tmpc"
    echo "#error no" >>"$tmpc"
    echo "#endif" >>"$tmpc"
    printf "检查用于构建的工具链包装器... "
    if test "$wrapper" = auto && ! $CC -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
        echo "none"
    elif test "$cc_family" = gcc; then
        gcc_wrapper=yes
        echo "gcc"
    elif test "$cc_family" = clang; then
        clang_wrapper=yes
        echo "clang"
    else
        echo "none"
        if test "$wrapper" = detect; then
            fail "$0: 找不到一个适合的包装器"
        fi
    fi
fi

if test "$gcc_wrapper" = yes; then
    tools="$tools obj/musl-gcc"
    tool_libs="$tool_libs lib/musl-gcc.specs"
fi
if test "$clang_wrapper" = yes; then
    tools="$tools obj/musl-clang obj/ld.musl-clang"
fi

#
# 找到编译目标平台架构
#
printf "检查编译目标架构类型... "
test -n "$target" || target=$($CC -dumpmachine 2>/dev/null) || target=unknown
printf "%s\n" "$target"

#
# $target 转化为环境变量 ARCH
#
case "$target" in
# 尽早进行匹配，以简化 32 位架构的构建配置
arm*) ARCH=arm ;;
aarch64*) ARCH=aarch64 ;;
i?86-nt32*) ARCH=nt32 ;;
i?86*) ARCH=i386 ;;
x86_64-x32* | x32* | x86_64*x32) ARCH=x32 ;;
x86_64-nt64*) ARCH=nt64 ;;
x86_64*) ARCH=x86_64 ;;
loongarch64*) ARCH=loongarch64 ;;
m68k*) ARCH=m68k ;;
mips64* | mipsisa64*) ARCH=mips64 ;;
mips*) ARCH=mips ;;
microblaze*) ARCH=microblaze ;;
or1k*) ARCH=or1k ;;
powerpc64* | ppc64*) ARCH=powerpc64 ;;
powerpc* | ppc*) ARCH=powerpc ;;
riscv64*) ARCH=riscv64 ;;
riscv32*) ARCH=riscv32 ;;
sh[1-9bel-]* | sh | superh*) ARCH=sh ;;
s390x*) ARCH=s390x ;;
unknown) fail "$0: 无法得到编译目标架构；尝试 $0 --target=..." ;;
*) fail "$0: 未知或不支持的结构：\"$target\"" ;;
esac

#
# 尝试配置一个符合C99标准的freestanding环境
#
tryflag CFLAGS_C99FSE -std=c99
tryflag CFLAGS_C99FSE -nostdinc
tryflag CFLAGS_C99FSE -ffreestanding ||
    tryflag CFLAGS_C99FSE -fno-builtin
tryflag CFLAGS_C99FSE -fexcess-precision=standard ||
    { test "$ARCH" = i386 && tryflag CFLAGS_C99FSE -ffloat-store; }
tryflag CFLAGS_C99FSE -frounding-math

#
# 关于编程语义，我们希望坚持我们的源代码遵循 C 语言的基于类型的别名规则，
# 但大多数，甚至几乎所有的实际编译器，都已知或怀疑在其基于类型的别名分析中
# 存在严重错误。参见 GCC 的 bug 107107。
#
tryflag CFLAGS_C99FSE -fno-strict-aliasing

#
# We may use the may_alias attribute if __GNUC__ is defined, so
# if the compiler defines __GNUC__ but does not provide it,
# it must be defined away as part of the CFLAGS.
#
printf "checking whether compiler needs attribute((may_alias)) suppression... "
cat >"$tmpc" <<EOF
typedef int
#ifdef __GNUC__
__attribute__((__may_alias__))
#endif
x;
EOF
if $CC $CFLAGS_C99FSE $CPPFLAGS $CFLAGS \
    -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
    printf "no\n"
else
    printf "yes\n"
    CFLAGS_C99FSE="$CFLAGS_C99FSE -D__may_alias__="
fi

#
# The GNU toolchain defaults to assuming unmarked files need an
# executable stack, potentially exposing vulnerabilities in programs
# linked with such object files. Fix this.
#
tryflag CFLAGS_C99FSE -Wa,--noexecstack

#
# Check for options to disable stack protector, which needs to be
# disabled for a few early-bootstrap translation units. If not found,
# this is not an error; we assume the toolchain does not do ssp.
#
tryflag CFLAGS_NOSSP -fno-stack-protector

#
# Check for options that may be needed to prevent the compiler from
# generating self-referential versions of memcpy,, memmove, memcmp,
# and memset. Really, we should add a check to determine if this
# option is sufficient, and if not, add a macro to cripple these
# functions with volatile...
#
tryflag CFLAGS_MEMOPS -fno-tree-loop-distribute-patterns

#
# Enable debugging if requessted.
#
test "$debug" = yes && CFLAGS_AUTO=-g

#
# Preprocess asm files to add extra debugging information if debug is
# enabled, our assembler supports the needed directives, and the
# preprocessing script has been written for our architecture.
#
printf "checking whether we should preprocess assembly to add debugging information... "
if fnmatch '-g*|*\ -g*' "$CFLAGS_AUTO $CFLAGS" &&
    test -f "$srcdir/tools/add-cfi.$ARCH.awk" &&
    printf ".file 1 \"srcfile.s\"\n.line 1\n.cfi_startproc\n.cfi_endproc" | $CC -g -x assembler -c -o /dev/null - 2>/dev/null; then
    ADD_CFI=yes
else
    ADD_CFI=no
fi
printf "%s\n" "$ADD_CFI"

#
# Possibly add a -O option to CFLAGS and select modules to optimize with
# -O3 based on the status of --enable-optimize and provided CFLAGS.
#
printf "checking for optimization settings... "
case "x$optimize" in
xauto)
    if fnmatch '-O*|*\ -O*' "$CFLAGS_AUTO $CFLAGS"; then
        printf "using provided CFLAGS\n"
        optimize=no
    else
        printf "using defaults\n"
        optimize=yes
    fi
    ;;
xsize | xnone)
    printf "minimize size\n"
    optimize=size
    ;;
xno | x)
    printf "disabled\n"
    optimize=no
    ;;
*) printf "custom\n" ;;
esac

if test "$optimize" = no; then
    :
else
    tryflag CFLAGS_AUTO -O2
    tryflag CFLAGS_AUTO -fno-align-jumps
    tryflag CFLAGS_AUTO -fno-align-functions
    tryflag CFLAGS_AUTO -fno-align-loops
    tryflag CFLAGS_AUTO -fno-align-labels
    tryflag CFLAGS_AUTO -fira-region=one
    tryflag CFLAGS_AUTO -fira-hoist-pressure
    tryflag CFLAGS_AUTO -freorder-blocks-algorithm=simple ||
        tryflag CFLAGS_AUTO -fno-reorder-blocks
    tryflag CFLAGS_AUTO -fno-prefetch-loop-arrays
    tryflag CFLAGS_AUTO -fno-tree-ch
fi
test "$optimize" = yes && optimize="internal,malloc,string"

if fnmatch 'no|size' "$optimize"; then
    :
else
    printf "components to be optimized for speed:"
    while test "$optimize"; do
        case "$optimize" in
        *,*) this=${optimize%%,*} optimize=${optimize#*,} ;;
        *) this=$optimize optimize= ;;
        esac
        printf " $this"
        case "$this" in
        */*.c) ;;
        */*) this=$this*.c ;;
        *) this=$this/*.c ;;
        esac
        OPTIMIZE_GLOBS="$OPTIMIZE_GLOBS $this"
    done
    OPTIMIZE_GLOBS=${OPTIMIZE_GLOBS# }
    printf "\n"
fi

# Always try -pipe
tryflag CFLAGS_AUTO -pipe

#
# If debugging is disabled, omit frame pointer. Modern GCC does this
# anyway on most archs even when debugging is enabled since the frame
# pointer is no longer needed for debugging.
#
if fnmatch '-g*|*\ -g*' "$CFLAGS_AUTO $CFLAGS"; then
    :
else
    tryflag CFLAGS_AUTO -fomit-frame-pointer
fi

#
# Modern GCC wants to put DWARF tables (used for debugging and
# unwinding) in the loaded part of the program where they are
# unstrippable. These options force them back to debug sections (and
# cause them not to get generated at all if debugging is off).
#
tryflag CFLAGS_AUTO -fno-unwind-tables
tryflag CFLAGS_AUTO -fno-asynchronous-unwind-tables

#
# Attempt to put each function and each data object in its own
# section. This both allows additional size optimizations at link
# time and works around a dangerous class of compiler/assembler bugs
# whereby relative address expressions are constant-folded by the
# assembler even when one or more of the symbols involved is
# replaceable. See gas pr 18561 and gcc pr 66609, 68178, etc.
#
tryflag CFLAGS_AUTO -ffunction-sections
tryflag CFLAGS_AUTO -fdata-sections

#
# On x86, make sure we don't have incompatible instruction set
# extensions enabled by default. This is bad for making static binaries.
# We cheat and use i486 rather than i386 because i386 really does not
# work anyway (issues with atomic ops).
# Some build environments pass -march and -mtune options via CC, so
# check both CC and CFLAGS.
#
if test "$ARCH" = "i386"; then
    fnmatch '-march=*|*\ -march=*' "$CC $CFLAGS" || tryldflag CFLAGS_AUTO -march=i486
    fnmatch '-mtune=*|*\ -mtune=*' "$CC $CFLAGS" || tryldflag CFLAGS_AUTO -mtune=generic
fi

#
# GCC defines -w as overriding any -W options, regardless of order, but
# clang has a bunch of annoying warnings enabled by default and needs -w
# to start from a clean slate. So use -w if building with clang. Also
# turn off a common on-by-default cast warning regardless of compiler.
#
test "$cc_family" = clang && tryflag CFLAGS_AUTO -w

tryflag CFLAGS_AUTO -Wno-pointer-to-int-cast

#
# Even with -std=c99, gcc accepts some constructs which are constraint
# violations. We want to treat these as errors regardless of whether
# other purely stylistic warnings are enabled -- especially implicit
# function declarations, which are a dangerous programming error.
#
tryflag CFLAGS_AUTO -Werror=implicit-function-declaration
tryflag CFLAGS_AUTO -Werror=implicit-int
tryflag CFLAGS_AUTO -Werror=pointer-sign
tryflag CFLAGS_AUTO -Werror=pointer-arith
tryflag CFLAGS_AUTO -Werror=int-conversion
tryflag CFLAGS_AUTO -Werror=incompatible-pointer-types
tryflag CFLAGS_AUTO -Werror=discarded-qualifiers
tryflag CFLAGS_AUTO -Werror=discarded-array-qualifiers

#
# GCC ignores unused arguements by default, but Clang needs this extra
# parameter to stop printing warnings about LDFLAGS passed during
# compiling stage and CFLAGS passed during linking stage.
#
test "$cc_family" = clang && tryflag CFLAGS_AUTO -Qunused-arguments

if test "x$warnings" = xyes; then
    tryflag CFLAGS_AUTO -Waddress
    tryflag CFLAGS_AUTO -Warray-bounds
    tryflag CFLAGS_AUTO -Wchar-subscripts
    tryflag CFLAGS_AUTO -Wduplicate-decl-specifier
    tryflag CFLAGS_AUTO -Winit-self
    tryflag CFLAGS_AUTO -Wreturn-type
    tryflag CFLAGS_AUTO -Wsequence-point
    tryflag CFLAGS_AUTO -Wstrict-aliasing
    tryflag CFLAGS_AUTO -Wunused-function
    tryflag CFLAGS_AUTO -Wunused-label
    tryflag CFLAGS_AUTO -Wunused-variable
fi

# Determine if the compiler produces position-independent code (PIC)
# by default. If so, we don't need to compile separate object files
# for libc.a and libc.so.
if trycppif __PIC__ "$CFLAGS_C99FSE $CPPFLAGS $CFLAGS"; then
    pic_default=yes
else
    pic_default=no
fi

# Reduce space lost to padding for alignment purposes by sorting data
# objects according to their alignment reqirements. This approximates
# optimal packing.
tryldflag LDFLAGS_AUTO -Wl,--sort-section,alignment
tryldflag LDFLAGS_AUTO -Wl,--sort-common

# When linking shared library, drop dummy weak definitions that were
# replaced by strong definitions from other translation units.
tryldflag LDFLAGS_AUTO -Wl,--gc-sections

# Some patched GCC builds have these defaults messed up...
tryldflag LDFLAGS_AUTO -Wl,--hash-style=both

# Prevent linking if there are undefined symbols; if any exist,
# libc.so will crash at runtime during relocation processing.
# The common way this can happen is failure to link the compiler
# runtime library; implementation error is also a possibility.
tryldflag LDFLAGS_AUTO -Wl,--no-undefined

# Avoid exporting symbols from compiler runtime libraries. They
# should be hidden anyway, but some toolchains including old gcc
# versions built without shared library support and pcc are broken.
tryldflag LDFLAGS_AUTO -Wl,--exclude-libs=ALL

# Public data symbols must be interposable to allow for copy
# relocations, but otherwise we want to bind symbols at libc link
# time to eliminate startup relocations and PLT overhead. Use
# --dynamic-list rather than -Bsymbolic-functions for greater
# control over what symbols are left unbound.
tryldflag LDFLAGS_AUTO -Wl,--dynamic-list="$srcdir/dynamic.list"

# Find compiler runtime library
test -z "$LIBCC" && tryldflag LIBCC -lgcc && tryldflag LIBCC -lgcc_eh
test -z "$LIBCC" && tryldflag LIBCC -lcompiler_rt
test -z "$LIBCC" && try_libcc=$($CC -print-libgcc-file-name 2>/dev/null) &&
    tryldflag LIBCC "$try_libcc"
test -z "$LIBCC" && try_libcc=$($CC -print-file-name=libpcc.a 2>/dev/null) &&
    tryldflag LIBCC "$try_libcc"
printf "using compiler runtime libraries: %s\n" "$LIBCC"

# Figure out arch variants for archs with variants
SUBARCH=
t="$CFLAGS_C99FSE $CPPFLAGS $CFLAGS"

if test "$ARCH" = "i386"; then
    printf "checking whether compiler can use ebx in PIC asm constraints... "
    cat >"$tmpc" <<EOF
int foo(int x) { __asm__ ( "" : "+b"(x) ); return x; }
EOF
    if $CC $CFLAGS_C99FSE $CPPFLAGS $CFLAGS -fPIC \
        -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
        printf "yes\n"
    else
        printf "no\n"
        CFLAGS_AUTO="$CFLAGS_AUTO -DBROKEN_EBX_ASM"
    fi
fi

if test "$ARCH" = "x86_64"; then
    trycppif __ILP32__ "$t" && ARCH=x32
fi

if test "$ARCH" = "arm"; then
    if trycppif __thumb2__ "$t"; then
        tryflag CFLAGS_AUTO -mimplicit-it=always
        tryflag CFLAGS_AUTO -Wa,-mimplicit-it=always
        tryflag CFLAGS_AUTO -Wa,-mthumb
    fi
    trycppif __ARMEB__ "$t" && SUBARCH=${SUBARCH}eb
    trycppif __ARM_PCS_VFP "$t" && SUBARCH=${SUBARCH}hf
    # Versions of clang up until at least 3.8 have the wrong constraint codes
    # for floating point operands to inline asm. Detect this so the affected
    # source files can just disable the asm.
    if test "$cc_family" = clang; then
        printf "checking whether clang's vfp asm constraints work... "
        echo 'float f(float x) { __asm__("":"+t"(x)); return x; }' >"$tmpc"
        if $CC $CFLAGS_C99FSE $CPPFLAGS $CFLAGS -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
            printf "yes\n"
        else
            printf "no\n"
            CFLAGS_AUTO="$CFLAGS_AUTO -DBROKEN_VFP_ASM"
            CFLAGS_AUTO="${CFLAGS_AUTO# }"
        fi
    fi
fi

if test "$ARCH" = "aarch64"; then
    trycppif __AARCH64EB__ "$t" && SUBARCH=${SUBARCH}_be
fi

if test "$ARCH" = "loongarch64"; then
    trycppif __loongarch_soft_float "$t" && SUBARCH=${SUBARCH}-sf
    trycppif __loongarch_single_float "$t" && SUBARCH=${SUBARCH}-sp
    printf "checking whether assembler support FCSRs... "
    echo "__asm__(\"movfcsr2gr \$t0,\$fcsr0\");" >"$tmpc"
    if $CC -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
        printf "yes\n"
    else
        printf "no\n"
        CFLAGS_AUTO="$CFLAGS_AUTO -DBROKEN_LOONGARCH_FCSR_ASM"
    fi
fi

if test "$ARCH" = "m68k"; then
    if trycppif "__HAVE_68881__"; then
        :
    elif trycppif "__mcffpu__"; then
        SUBARCH="-fp64"
    else
        SUBARCH="-sf"
    fi
fi

if test "$ARCH" = "mips"; then
    trycppif "__mips_isa_rev >= 6" "$t" && SUBARCH=${SUBARCH}r6
    trycppif "_MIPSEL || __MIPSEL || __MIPSEL__" "$t" && SUBARCH=${SUBARCH}el
    trycppif __mips_soft_float "$t" && SUBARCH=${SUBARCH}-sf
fi

if test "$ARCH" = "mips64"; then
    trycppif "_MIPS_SIM != _ABI64" "$t" && ARCH=mipsn32
    trycppif "__mips_isa_rev >= 6" "$t" && SUBARCH=${SUBARCH}r6
    trycppif "_MIPSEL || __MIPSEL || __MIPSEL__" "$t" && SUBARCH=${SUBARCH}el
    trycppif __mips_soft_float "$t" && SUBARCH=${SUBARCH}-sf
fi

if test "$ARCH" = "powerpc"; then
    trycppif "_SOFT_FLOAT || __NO_FPRS__" "$t" && SUBARCH=${SUBARCH}-sf
    printf "checking whether compiler can use 'd' constraint in asm... "
    echo 'double f(double x) { __asm__ ("fabs %0, %1" : "=d"(x) : "d"(x)); return x; }' >"$tmpc"
    if $CC $CFLAGS_C99FSE $CPPFLAGS $CFLAGS -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
        printf "yes\n"
    else
        printf "no\n"
        CFLAGS_AUTO="$CFLAGS_AUTO -DBROKEN_PPC_D_ASM"
        CFLAGS_AUTO="${CFLAGS_AUTO# }"
    fi
fi

test "$ARCH" = "microblaze" && trycppif __MICROBLAZEEL__ "$t" &&
    SUBARCH=${SUBARCH}el

if test "$ARCH" = "powerpc64"; then
    trycppif "_CALL_ELF == 2" "$t" || fail "$0: error: unsupported powerpc64 ABI"
    trycppif __LITTLE_ENDIAN__ "$t" && SUBARCH=${SUBARCH}le
    trycppif _SOFT_FLOAT "$t" && fail "$0: error: soft-float not supported on powerpc64"
fi

if test "$ARCH" = "riscv64" -o "$ARCH" = "riscv32"; then
    trycppif __riscv_float_abi_soft "$t" && SUBARCH=${SUBARCH}-sf
    trycppif __riscv_float_abi_single "$t" && SUBARCH=${SUBARCH}-sp
fi

if test "$ARCH" = "sh"; then
    tryflag CFLAGS_AUTO -Wa,--isa=any
    trycppif __BIG_ENDIAN__ "$t" && SUBARCH=${SUBARCH}eb
    if trycppif "__SH_FPU_ANY__ || __SH4__" "$t"; then
        # Some sh configurations are broken and replace double with float
        # rather than using softfloat when the fpu is present but only
        # supports single precision. Reject them.
        printf "checking whether compiler's double type is IEEE double... "
        echo 'typedef char dblcheck[(int)sizeof(double)-5];' >"$tmpc"
        if $CC $CFLAGS_C99FSE $CPPFLAGS $CFLAGS -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
            printf "yes\n"
        else
            printf "no\n"
            fail "$0: error: compiler's floating point configuration is unsupported"
        fi
    else
        SUBARCH=${SUBARCH}-nofpu
    fi
    if trycppif __SH_FDPIC__ "$t"; then
        SUBARCH=${SUBARCH}-fdpic
    fi
fi

test "$SUBARCH" &&
    printf "configured for %s variant: %s\n" "$ARCH" "$ARCH$SUBARCH"

#
# Some archs (powerpc) have different possible long double formats
# that the compiler can be configured for. The logic for whether this
# is supported is in bits/float.h; in general, it is not. We need to
# check for mismatches here or code in printf, strotd, and scanf will
# be dangerously incorrect because it depends on (1) the macros being
# correct, and (2) IEEE semantics.
#
printf "checking whether compiler's long double definition matches float.h... "
echo '#include <float.h>' >"$tmpc"
echo '#define C(m,s) (m==LDBL_MANT_DIG && s==sizeof(long double))' >>"$tmpc"
echo 'typedef char ldcheck[(C(53,8)||C(64,12)||C(64,16)||C(113,16))*2-1];' >>"$tmpc"
if $CC $CFLAGS_C99FSE \
    -I$srcdir/arch/$ARCH -I$srcdir/arch/generic -I$srcdir/include \
    $CPPFLAGS $CFLAGS -c -o /dev/null "$tmpc" >/dev/null 2>&1; then
    printf "yes\n"
else
    printf "no\n"
    fail "$0: error: unsupported long double type"
fi

#
# Some build systems globally pass in broken CFLAGS like -ffast-math
# for all packages. On recent GCC we can detect this and error out
# early rather than producing a seriously-broken math library.
#
if trycppif "__FAST_MATH__" \
    "$CFLAGS_C99FSE $CPPFLAGS $CFLAGS"; then
    fail "$0: error: compiler has broken floating point; check CFLAGS"
fi

printf "creating config.mak... "

cmdline=$(quote "$0")
for i; do cmdline="$cmdline $(quote "$i")"; done

exec 3>&1 1>config.mak

cat <<EOF
# This version of config.mak was generated by:
# $cmdline
# Any changes made here will be lost if configure is re-run
AR = ${AR:-\$(CROSS_COMPILE)ar}
RANLIB = ${RANLIB:-\$(CROSS_COMPILE)ranlib}
ARCH = $ARCH
SUBARCH = $SUBARCH
ASMSUBARCH = $ASMSUBARCH
srcdir = $srcdir
prefix = $prefix
exec_prefix = $exec_prefix
bindir = $bindir
libdir = $libdir
includedir = $includedir
syslibdir = $syslibdir
CC = $CC
CFLAGS = $CFLAGS
CFLAGS_AUTO = $CFLAGS_AUTO
CFLAGS_C99FSE = $CFLAGS_C99FSE
CFLAGS_MEMOPS = $CFLAGS_MEMOPS
CFLAGS_NOSSP = $CFLAGS_NOSSP
CPPFLAGS = $CPPFLAGS
LDFLAGS = $LDFLAGS
LDFLAGS_AUTO = $LDFLAGS_AUTO
CROSS_COMPILE = $CROSS_COMPILE
LIBCC = $LIBCC
OPTIMIZE_GLOBS = $OPTIMIZE_GLOBS
ALL_TOOLS = $tools
TOOL_LIBS = $tool_libs
ADD_CFI = $ADD_CFI
MALLOC_DIR = $malloc_dir
EOF
test "x$static" = xno && echo "STATIC_LIBS ="
test "x$shared" = xno && echo "SHARED_LIBS ="
test "x$cc_family" = xgcc && echo 'WRAPCC_GCC = $(CC)'
test "x$cc_family" = xclang && echo 'WRAPCC_CLANG = $(CC)'
test "x$pic_default" = xyes && echo 'AOBJS = $(LOBJS)'
exec 1>&3 3>&-

test "$srcdir" = "." || ln -sf $srcdir/Makefile .

printf "done\n"
